import {expect, test, vi} from 'vitest';
import {main} from './index';
import * as getBaseSchemaModule from './getBaseSchema';

// Mock the getBaseSchema function
vi.mock('./getBaseSchema', () => ({
	getBaseSchema: vi.fn(),
}));

const mockGetBaseSchema = vi.mocked(getBaseSchemaModule.getBaseSchema);

test('main generates TypeScript code correctly', async () => {
	// GIVEN a comprehensive mock base schema with various field types and edge cases
	const mockBaseSchema = [
		{
			id: 'tblTest123',
			name: 'Test Table',
			fields: [
				{
					id: 'fld1',
					name: 'Name',
					type: 'singleLineText',
				},
				{
					id: 'fld2',
					name: '% amount',
					type: 'number',
					options: {precision: 2},
				},
				{
					id: 'fld3',
					name: '$ price',
					type: 'number',
					options: {precision: 2},
				},
				{
					id: 'fld4',
					name: '@ email',
					type: 'email',
				},
				{
					id: 'fld5',
					name: 'Status',
					type: 'singleSelect',
					options: {
						choices: [
							{id: 'sel1', name: 'Active', color: 'green'},
							{id: 'sel2', name: 'Inactive', color: 'red'},
						],
					},
				},
				{
					id: 'fld6',
					name: 'Multi-word Field Name',
					type: 'multilineText',
				},
				{
					id: 'fld7',
					name: 'Field with "quotes" and symbols!',
					type: 'singleLineText',
				},
				{
					id: 'fld8',
					name: '123 Numeric Start',
					type: 'number',
					options: {precision: 0},
				},
				{
					id: 'fld9',
					name: 'checkbox field',
					type: 'checkbox',
				},
				{
					id: 'fld10',
					name: 'Unsupported Field',
					type: 'unsupportedType',
				},
			],
			views: [],
		},
		{
			id: 'tblProjects',
			name: 'Projects',
			fields: [
				{
					id: 'fldProjName',
					name: 'Project Name',
					type: 'singleLineText',
				},
				{
					id: 'fldProjOwner',
					name: 'Owner',
					type: 'singleLineText',
				},
			],
			views: [],
		},
	];

	mockGetBaseSchema.mockResolvedValue(mockBaseSchema);

	const config = {
		apiKey: 'test-key',
		baseId: 'appTest123',
	};

	// WHEN we generate the code
	const result = await main(config);

	// THEN the generated code should match the snapshot
	expect(result).toMatchInlineSnapshot(`
		"/* DO NOT EDIT: this file was automatically generated by airtable-ts-codegen */
		/* eslint-disable */
		import type { Item, Table } from 'airtable-ts';

		export interface TestTable extends Item {
		  id: string,
		  name: string | null, // Original field: "Name"
		  amount: number | null, // Original field: "% amount"
		  price: number | null, // Original field: "$ price"
		  email: string | null, // Original field: "@ email"
		  status: string | null, // Original field: "Status"
		  multiWordFieldName: string | null, // Original field: "Multi-word Field Name"
		  fieldWithQuotesAndSymbols: string | null, // Original field: "Field with "quotes" and symbols!"
		  _123numericstart: number | null, // Original field: "123 Numeric Start"
		  checkboxField: boolean, // Original field: "checkbox field"
		  // Unsupported field "Unsupported Field" of type unsupportedType
		}

		export const TestTabletable: Table<TestTable> = {
		  name: 'Test Table',
		  baseId: 'appTest123',
		  tableId: 'tblTest123',
		  mappings: {
		    name: 'fld1', // Original field: "Name"
		    amount: 'fld2', // Original field: "% amount"
		    price: 'fld3', // Original field: "$ price"
		    email: 'fld4', // Original field: "@ email"
		    status: 'fld5', // Original field: "Status"
		    multiWordFieldName: 'fld6', // Original field: "Multi-word Field Name"
		    fieldWithQuotesAndSymbols: 'fld7', // Original field: "Field with "quotes" and symbols!"
		    _123numericstart: 'fld8', // Original field: "123 Numeric Start"
		    checkboxField: 'fld9', // Original field: "checkbox field"
		    // Unsupported field "Unsupported Field": fld10
		  },
		  schema: {
		    name: 'string | null',
		    amount: 'number | null',
		    price: 'number | null',
		    email: 'string | null',
		    status: 'string | null',
		    multiWordFieldName: 'string | null',
		    fieldWithQuotesAndSymbols: 'string | null',
		    _123numericstart: 'number | null',
		    checkboxField: 'boolean',
		  },
		};

		export interface Project extends Item {
		  id: string,
		  projectName: string | null, // Original field: "Project Name"
		  owner: string | null, // Original field: "Owner"
		}

		export const projectsTable: Table<Project> = {
		  name: 'Projects',
		  baseId: 'appTest123',
		  tableId: 'tblProjects',
		  mappings: {
		    projectName: 'fldProjName', // Original field: "Project Name"
		    owner: 'fldProjOwner', // Original field: "Owner"
		  },
		  schema: {
		    projectName: 'string | null',
		    owner: 'string | null',
		  },
		};"
	`);

	// Verify the mock was called correctly
	expect(mockGetBaseSchema).toHaveBeenCalledWith('appTest123', config);
});

test('main handles duplicate field names with numbering', async () => {
	// GIVEN a mock base schema with fields that would create duplicate identifiers
	const mockBaseSchema = [
		{
			id: 'tblDuplicates',
			name: 'Duplicate Test',
			fields: [
				{
					id: 'fld1',
					name: '% amount',
					type: 'number',
					options: {precision: 2},
				},
				{
					id: 'fld2',
					name: '$ amount',
					type: 'number',
					options: {precision: 2},
				},
				{
					id: 'fld3',
					name: '@ amount',
					type: 'number',
					options: {precision: 2},
				},
				{
					id: 'fld4',
					name: '# amount',
					type: 'number',
					options: {precision: 2},
				},
			],
			views: [],
		},
	];

	mockGetBaseSchema.mockResolvedValue(mockBaseSchema);

	const config = {
		apiKey: 'test-key',
		baseId: 'appDuplicates',
	};

	// WHEN we generate the code
	const result = await main(config);

	// THEN the generated code should handle duplicates with numbering
	expect(result).toMatchInlineSnapshot(`
		"/* DO NOT EDIT: this file was automatically generated by airtable-ts-codegen */
		/* eslint-disable */
		import type { Item, Table } from 'airtable-ts';

		export interface DuplicateTest extends Item {
		  id: string,
		  amount: number | null, // Original field: "% amount"
		  amount2: number | null, // Original field: "$ amount"
		  amount3: number | null, // Original field: "@ amount"
		  amount4: number | null, // Original field: "# amount"
		}

		export const DuplicateTesttable: Table<DuplicateTest> = {
		  name: 'Duplicate Test',
		  baseId: 'appDuplicates',
		  tableId: 'tblDuplicates',
		  mappings: {
		    amount: 'fld1', // Original field: "% amount"
		    amount2: 'fld2', // Original field: "$ amount"
		    amount3: 'fld3', // Original field: "@ amount"
		    amount4: 'fld4', // Original field: "# amount"
		  },
		  schema: {
		    amount: 'number | null',
		    amount2: 'number | null',
		    amount3: 'number | null',
		    amount4: 'number | null',
		  },
		};"
	`);

	// Verify the mock was called correctly
	expect(mockGetBaseSchema).toHaveBeenCalledWith('appDuplicates', config);
});

test('main generates TypeScript code for grid view with visible fields only', async () => {
	// GIVEN a comprehensive mock base schema with views included
	const mockBaseSchema = [
		{
			id: 'tblTest123',
			name: 'Test Table',
			fields: [
				{
					id: 'fld1',
					name: 'Name',
					type: 'singleLineText',
				},
				{
					id: 'fld2',
					name: 'Hidden Field',
					type: 'number',
					options: {precision: 2},
				},
				{
					id: 'fld3',
					name: 'Status',
					type: 'singleSelect',
					options: {
						choices: [
							{id: 'sel1', name: 'Active', color: 'green'},
							{id: 'sel2', name: 'Inactive', color: 'red'},
						],
					},
				},
				{
					id: 'fld4',
					name: 'Another Hidden Field',
					type: 'multilineText',
				},
				{
					id: 'fld5',
					name: 'Visible Field',
					type: 'checkbox',
				},
			],
			views: [
				{
					id: 'viwQpsuEDqHFqegkp',
					name: 'My Grid View',
					type: 'grid' as const,
					visibleFieldIds: ['fld1', 'fld3', 'fld5'],
				},
			],
		},
	];

	mockGetBaseSchema.mockResolvedValue(mockBaseSchema);

	const config = {
		apiKey: 'test-key',
		baseId: 'appTest123',
		viewIds: ['viwQpsuEDqHFqegkp'],
	};

	// WHEN we generate the code with view
	const result = await main(config);

	// THEN the generated code should only include visible fields
	expect(result).toMatchInlineSnapshot(`
		"/* DO NOT EDIT: this file was automatically generated by airtable-ts-codegen */
		/* eslint-disable */
		import type { Item, Table } from 'airtable-ts';

		export interface TestTable extends Item {
		  id: string,
		  name: string | null, // Original field: "Name"
		  status: string | null, // Original field: "Status"
		  visibleField: boolean, // Original field: "Visible Field"
		}

		export const TestTabletable: Table<TestTable> = {
		  name: 'Test Table',
		  baseId: 'appTest123',
		  tableId: 'tblTest123',
		  mappings: {
		    name: 'fld1', // Original field: "Name"
		    status: 'fld3', // Original field: "Status"
		    visibleField: 'fld5', // Original field: "Visible Field"
		  },
		  schema: {
		    name: 'string | null',
		    status: 'string | null',
		    visibleField: 'boolean',
		  },
		};"
	`);

	// Verify the mock was called correctly
	expect(mockGetBaseSchema).toHaveBeenCalledWith('appTest123', config);
});

test('main generates TypeScript code for non-grid view with all fields', async () => {
	// GIVEN a comprehensive mock base schema with a non-grid view
	const mockBaseSchema = [
		{
			id: 'tblTest123',
			name: 'Test Table',
			fields: [
				{
					id: 'fld1',
					name: 'Name',
					type: 'singleLineText',
				},
				{
					id: 'fld2',
					name: 'Amount',
					type: 'number',
					options: {precision: 2},
				},
			],
			views: [
				{
					id: 'viwi3KXvrKug2mIBS',
					name: 'Project Plan (Gantt Chart)',
					type: 'block' as const,
				},
			],
		},
	];

	mockGetBaseSchema.mockResolvedValue(mockBaseSchema);

	const config = {
		apiKey: 'test-key',
		baseId: 'appTest123',
		viewIds: ['viwi3KXvrKug2mIBS'],
	};

	// WHEN we generate the code with view
	const result = await main(config);

	// THEN the generated code should include all fields (since non-grid views don't filter)
	expect(result).toMatchInlineSnapshot(`
		"/* DO NOT EDIT: this file was automatically generated by airtable-ts-codegen */
		/* eslint-disable */
		import type { Item, Table } from 'airtable-ts';

		export interface TestTable extends Item {
		  id: string,
		  name: string | null, // Original field: "Name"
		  amount: number | null, // Original field: "Amount"
		}

		export const TestTabletable: Table<TestTable> = {
		  name: 'Test Table',
		  baseId: 'appTest123',
		  tableId: 'tblTest123',
		  mappings: {
		    name: 'fld1', // Original field: "Name"
		    amount: 'fld2', // Original field: "Amount"
		  },
		  schema: {
		    name: 'string | null',
		    amount: 'number | null',
		  },
		};"
	`);

	// Verify the mock was called correctly
	expect(mockGetBaseSchema).toHaveBeenCalledWith('appTest123', config);
});

test('main throws error when view ID does not exist in any table', async () => {
	// GIVEN a mock base schema without the requested view
	const mockBaseSchema = [
		{
			id: 'tblTest123',
			name: 'Test Table',
			fields: [
				{
					id: 'fld1',
					name: 'Name',
					type: 'singleLineText',
				},
			],
			views: [
				{
					id: 'viwExistingView',
					name: 'Existing View',
					type: 'grid' as const,
				},
			],
		},
	];

	mockGetBaseSchema.mockResolvedValue(mockBaseSchema);

	const config = {
		apiKey: 'test-key',
		baseId: 'appTest123',
		viewIds: ['viwNonExistentView'],
	};

	// WHEN we try to generate code with a non-existent view
	// THEN it should throw a helpful error message
	await expect(main(config)).rejects.toThrow('View "viwNonExistentView" not found in any table. Please check the view ID is correct.');
});

test('main generates TypeScript code for multiple view IDs', async () => {
	// GIVEN a mock base schema with multiple tables and views
	const mockBaseSchema = [
		{
			id: 'tblTable1',
			name: 'Table 1',
			fields: [
				{
					id: 'fld1',
					name: 'Name',
					type: 'singleLineText',
				},
				{
					id: 'fld2',
					name: 'Hidden Field',
					type: 'number',
				},
				{
					id: 'fld3',
					name: 'Visible Field',
					type: 'checkbox',
				},
			],
			views: [
				{
					id: 'viwGrid1',
					name: 'Grid View 1',
					type: 'grid' as const,
					visibleFieldIds: ['fld1', 'fld3'],
				},
			],
		},
		{
			id: 'tblTable2',
			name: 'Table 2',
			fields: [
				{
					id: 'fld4',
					name: 'Title',
					type: 'singleLineText',
				},
				{
					id: 'fld5',
					name: 'Description',
					type: 'multilineText',
				},
			],
			views: [
				{
					id: 'viwForm1',
					name: 'Form View 1',
					type: 'form' as const,
				},
			],
		},
	];

	mockGetBaseSchema.mockResolvedValue(mockBaseSchema);

	const config = {
		apiKey: 'test-key',
		baseId: 'appTest123',
		viewIds: ['viwGrid1', 'viwForm1'],
	};

	// WHEN we generate the code with multiple view IDs
	const result = await main(config);

	// THEN the generated code should include both tables
	expect(result).toMatchInlineSnapshot(`
		"/* DO NOT EDIT: this file was automatically generated by airtable-ts-codegen */
		/* eslint-disable */
		import type { Item, Table } from 'airtable-ts';

		export interface Table1 extends Item {
		  id: string,
		  name: string | null, // Original field: "Name"
		  visibleField: boolean, // Original field: "Visible Field"
		}

		export const Table1table: Table<Table1> = {
		  name: 'Table 1',
		  baseId: 'appTest123',
		  tableId: 'tblTable1',
		  mappings: {
		    name: 'fld1', // Original field: "Name"
		    visibleField: 'fld3', // Original field: "Visible Field"
		  },
		  schema: {
		    name: 'string | null',
		    visibleField: 'boolean',
		  },
		};

		export interface Table2 extends Item {
		  id: string,
		  title: string | null, // Original field: "Title"
		  description: string | null, // Original field: "Description"
		}

		export const Table2table: Table<Table2> = {
		  name: 'Table 2',
		  baseId: 'appTest123',
		  tableId: 'tblTable2',
		  mappings: {
		    title: 'fld4', // Original field: "Title"
		    description: 'fld5', // Original field: "Description"
		  },
		  schema: {
		    title: 'string | null',
		    description: 'string | null',
		  },
		};"
	`);

	// Verify the mock was called correctly
	expect(mockGetBaseSchema).toHaveBeenCalledWith('appTest123', config);
});
