import {recase} from '@kristiandupont/recase';
import {type BaseSchema, type FieldSchema, getBaseSchema} from './getBaseSchema';
import {escapeString} from './escape/escapeString';
import {escapeIdentifier, resetIdentifierState} from './escape/escapeIdentifier';
import {jsTypeForAirtableType, type JsTypeOptions} from './jsTypeForAirtableType';
import {filterBaseSchemaByView} from './view';

export type Config = {
	apiKey: string;
	baseId: string;
	viewIds?: string[];
	endpointUrl?: string;
	requestTimeout?: number;
	customHeaders?: Record<string, string | number | boolean>;
	/**
	 * Type to use for multipleAttachments fields.
	 * - 'string': generates `string[]` (array of URLs only)
	 * - 'Attachment': generates `Attachment[]` (full metadata including id, filename, size, etc.)
	 * @default 'string'
	 * @unstable This option may change or be removed in future versions.
	 */
	unstable_attachmentType?: 'string' | 'Attachment';
};

// This generates a single typescript file containing all table definitions for a given base.
export const main = async (config: Config) => {
	const baseSchema = await getBaseSchema(config.baseId, config);
	const filteredBaseSchema = await filterBaseSchemaByView(baseSchema, config);

	// Determine if we need to import Attachment type
	const useAttachmentType = config.unstable_attachmentType === 'Attachment';
	const importTypes = useAttachmentType
		? 'import type { Attachment, Item, Table } from \'airtable-ts\';'
		: 'import type { Item, Table } from \'airtable-ts\';';

	return [
		'/* DO NOT EDIT: this file was automatically generated by airtable-ts-codegen */',
		'/* eslint-disable */',
		importTypes,
		'',
		filteredBaseSchema.map((tableSchema) => generateCode(config, tableSchema)).join('\n\n'),
	].join('\n');
};

type FieldWithJsInfo = FieldSchema & {jsName: string; jsType: string | null; originalName: string};

const generateInterfaceEntry = ({jsName, jsType, name, type, originalName}: FieldWithJsInfo): string => {
	if (jsType === null) {
		return `\n  // Unsupported field "${name}" of type ${type}`;
	}

	const comment = originalName !== jsName ? ` // Original field: "${originalName}"` : '';
	return `\n  ${jsName}: ${jsType},${comment}`;
};

const generateMappingEntry = ({jsName, id, jsType, name, originalName}: FieldWithJsInfo): string => {
	if (jsType === null) {
		return `\n    // Unsupported field "${name}": ${escapeString(id)}`;
	}

	const comment = originalName !== jsName ? ` // Original field: "${originalName}"` : '';
	return `\n    ${jsName}: '${escapeString(id)}',${comment}`;
};

const generateSchemaEntry = ({jsName, jsType}: FieldWithJsInfo): string | null => {
	if (jsType === null) {
		return null;
	}

	return `\n    ${jsName}: '${escapeString(jsType)}',`;
};

const generateCode = (config: Config, tableSchema: BaseSchema[number]): string => {
	resetIdentifierState();

	const itemNameRaw = escapeIdentifier(recase(null, 'pascal', tableSchema.name));
	const itemName = /.s$/.test(itemNameRaw) ? itemNameRaw.slice(0, itemNameRaw.length - 1) : itemNameRaw;
	const tableName = escapeIdentifier(`${recase(null, 'camel', tableSchema.name)}Table`);

	const jsTypeOptions: JsTypeOptions = {attachmentType: config.unstable_attachmentType};
	const fields: FieldWithJsInfo[] = tableSchema.fields.map((f) => ({
		...f,
		originalName: f.name,
		jsName: escapeIdentifier(recase(null, 'camel', escapeIdentifier(f.name))),
		jsType: jsTypeForAirtableType(f, jsTypeOptions),
	}));

	return `export interface ${itemName} extends Item {
  id: string,${fields.map(generateInterfaceEntry).join('')}
}

export const ${tableName}: Table<${itemName}> = {
  name: '${escapeString(tableSchema.name)}',
  baseId: '${escapeString(config.baseId)}',
  tableId: '${escapeString(tableSchema.id)}',
  mappings: {${fields.map(generateMappingEntry).join('')}
  },
  schema: {${fields.map(generateSchemaEntry).filter(Boolean).join('')}
  },
};`;
};
